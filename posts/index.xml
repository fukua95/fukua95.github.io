<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on cxljs</title>
    <link>https://cxljs.github.io/posts/</link>
    <description>Recent content in Posts on cxljs</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Aug 2025 19:06:59 +0800</lastBuildDate>
    <atom:link href="https://cxljs.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JuiceFS 设计</title>
      <link>https://cxljs.github.io/posts/juicefs/</link>
      <pubDate>Fri, 01 Aug 2025 19:06:59 +0800</pubDate>
      <guid>https://cxljs.github.io/posts/juicefs/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95&#34;&gt;分布式文件系统的发展&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9A%BE%E7%82%B9&#34;&gt;分布式文件系统的难点&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#juicefs&#34;&gt;JuiceFS&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE&#34;&gt;存储文件数据&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%85%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1&#34;&gt;元数据结构设计&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B&#34;&gt;读写流程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;分布式文件系统的发展&#34;&gt;分布式文件系统的发展&lt;/h1&gt;&#xA;&lt;p&gt;Google GFS 的发表应该是分布式文件系统发展的里程碑，Meta + Data 的架构影响了后来的分布式系统设计。随后的 HDFS 是大数据时代最重要的存储系统之一，现在分布式文件系统最流行的2种接口协议是 POSIX 和 HDFS 接口协议。&lt;/p&gt;&#xA;&lt;p&gt;随着云原生和对象存储的发展，分布式系统的设计趋势是把数据放到对象存储，比如 autoMQ 把 Kafka 的数据放到对象存储，AWS 刚发布的基于对象存储的向量数据库。&lt;/p&gt;&#xA;&lt;p&gt;对分布式文件系统的需求也有变化，相比大数据时代，AI 训练存储的更多是中小文件，所以文件系统的元数据更多。&lt;/p&gt;&#xA;&lt;h1 id=&#34;分布式文件系统的难点&#34;&gt;分布式文件系统的难点&lt;/h1&gt;&#xA;&lt;p&gt;文件系统的元数据组成一个 DAG，分布式文件系统的难点在于：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;怎么存储这个 DAG？&lt;/li&gt;&#xA;&lt;li&gt;怎么高并发的读写这个 DAG？&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;几种思路：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;整个 DAG 存储在单个节点，缺点是单节点容量有限，DAG size 成为系统瓶颈。&lt;/li&gt;&#xA;&lt;li&gt;转化为 KV/Relation 存储在 KV/Relational DB。&lt;/li&gt;&#xA;&lt;li&gt;设计一个可扩展的存储 DAG 的系统，把 DAG 划分存储到多个节点，目前没有这样做的开源项目(?)，但是有相关的论文，应该有公司实现了/在做这个。&lt;/li&gt;&#xA;&lt;li&gt;不采用 Meta + Data 架构，把 Meta 和 Data 混合存储。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;juicefs&#34;&gt;JuiceFS&lt;/h1&gt;&#xA;&lt;p&gt;JuiceFS 的元数据采用第2种思路，支持 TiKV/MySQL 等多个系统作为 Meta Service，甚至还支持 Redis (在一致性要求不高的场景使用)，数据放在对象存储。&lt;/p&gt;&#xA;&lt;p&gt;架构：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;app         go-fuse --&amp;gt; juicefs --&amp;gt; local meta cache --&amp;gt; meta service&#xA; |            |            |&#xA;syscall      fd             --&amp;gt; local data cache --&amp;gt; object storage service&#xA; |            |&#xA;vfs    --&amp;gt;   fuse&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;存储文件数据&#34;&gt;存储文件数据&lt;/h2&gt;&#xA;&lt;p&gt;当写文件时，元数据放在 Meta Service，数据放在对象存储。如果一个文件作为一个对象去存储，当读一部分/修改文件时，会有严重的读写放大，特别是大文件，所以需要把文件划分成多个对象去存储。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LevelDB #1 WAL</title>
      <link>https://cxljs.github.io/posts/leveldb-1-wal/</link>
      <pubDate>Sun, 09 Mar 2025 17:36:52 +0800</pubDate>
      <guid>https://cxljs.github.io/posts/leveldb-1-wal/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#leveldb-overview&#34;&gt;LevelDB Overview&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#wal&#34;&gt;WAL&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#log-file-format&#34;&gt;Log File Format&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#log-writer&#34;&gt;Log Writer&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#log-reader&#34;&gt;Log Reader&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;leveldb-overview&#34;&gt;LevelDB Overview&lt;/h1&gt;&#xA;&lt;p&gt;lsm-tree 设计思路：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;写日志，从而把写操作变成磁盘顺序写&lt;/li&gt;&#xA;&lt;li&gt;写先存储在内存，再批量写入新文件，保证每个文件的数据有序，方便合并，删除失效数据&lt;/li&gt;&#xA;&lt;li&gt;分层合并策略&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;LevelDB 是 BigTable 的存储引擎，是最早流行的使用 lsm-tree 的存储引擎。&lt;/p&gt;&#xA;&lt;p&gt;LevelDB 架构图(在网上广为流传，应该是出自 MS 的一篇文章):&#xA;&lt;img src=&#34;img/arch.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;LevelDB 系列文章的顺序：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;WAL&lt;/li&gt;&#xA;&lt;li&gt;MemTable&lt;/li&gt;&#xA;&lt;li&gt;SSTables 格式，压缩、合并&lt;/li&gt;&#xA;&lt;li&gt;其他工程优化：Bloom Filter, Block Cache, Lock, Env&lt;/li&gt;&#xA;&lt;li&gt;MVCC 并发控制&lt;/li&gt;&#xA;&lt;li&gt;完整读写流程&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;wal&#34;&gt;WAL&lt;/h1&gt;&#xA;&lt;p&gt;为了保证 MemTable 的数据不丢失，在写 MemTable 前会先写 WAL，重启时，重放 WAL 恢复 MemTable。正常情况一个 MemTable 对应一个 WAL，WAL 在 MemTable 成功落盘后删除。&lt;/p&gt;&#xA;&lt;p&gt;所以 WAL 应该有2个接口：&lt;code&gt;AddRecord()&lt;/code&gt; 和 &lt;code&gt;Replay()&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;LevelDB&amp;rsquo;s WAL 分成 &lt;code&gt;log::Writer&lt;/code&gt; 和 &lt;code&gt;log::Reader&lt;/code&gt; 2个数据结构。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis 主流程实现</title>
      <link>https://cxljs.github.io/posts/redis/</link>
      <pubDate>Sat, 13 Jul 2024 15:28:13 +0800</pubDate>
      <guid>https://cxljs.github.io/posts/redis/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#util&#34;&gt;Util&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6&#34;&gt;网络框架&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82&#34;&gt;处理请求&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%8E%A5%E5%8F%97%E6%96%B0%E8%BF%9E%E6%8E%A5&#34;&gt;接受新连接&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4&#34;&gt;解析命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4&#34;&gt;执行命令&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%8F%91%E9%80%81%E5%9B%9E%E5%A4%8D&#34;&gt;发送回复&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#servers-db-%E8%AE%BE%E8%AE%A1&#34;&gt;Server&amp;rsquo;s DB 设计&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#34;&gt;数据结构&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Redis 是一个 in-memory data structures server, 在互联网应用广泛，常见的使用场景:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;作为其他系统的缓存，减少其他系统的负载，相比于本地缓存，Redis 可以让多个实例共享缓存的数据&lt;/li&gt;&#xA;&lt;li&gt;对延时要求高的场景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在高性能的前提下，我觉得 Redis 的接口设计是它能从 memcached 等系统中脱颖而出的关键原因，Redis 支持 hash table, set, sorted set, vector set 等数据结构，对用户更加友好，还支持 timeseries, pub/sub, stream 等，使它有更多的使用场景。&lt;/p&gt;&#xA;&lt;p&gt;类似 S3, Redis API 被称为 Redis 协议，很多 KV 系统都支持 Redis 协议，比如阿里的 Tair。&lt;/p&gt;&#xA;&lt;p&gt;Redis 单机的整体架构主要分4个部分：网络框架、线程模型、内存数据结构、持久化。&lt;/p&gt;&#xA;&lt;p&gt;这篇文章讲 Redis 主流程的实现。&lt;/p&gt;&#xA;&lt;h2 id=&#34;util&#34;&gt;Util&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;lzf[.h/_c.c]&lt;/code&gt;实现 lzf 压缩算法，RDB 持久化时默认使用 lzf 压缩 key&amp;amp;value.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;zmalloc.[h/c]&lt;/code&gt;是 malloc wrapper, 记录使用的堆内存量。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;sds.[h/c]&lt;/code&gt;实现变长字符串类型，是内部最常用的数据结构，很多 buffer 的类型是 &lt;code&gt;sds&lt;/code&gt;，分配内存的策略:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
